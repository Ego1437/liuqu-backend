package com.omate.liuqu.controller;

import com.omate.liuqu.dto.*;
import com.omate.liuqu.model.*;
import com.omate.liuqu.repository.*;
import com.omate.liuqu.service.*;
import com.omate.liuqu.utils.*;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import jakarta.persistence.EntityNotFoundException;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/api") // This means URL's start with /demo (after Application path)
public class UserController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserService userService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder passwordEncoder;

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * *
     * 
     * @param user
     * @return userDTO
     */
    public UserDTO convertToDto(User user) {
        UserDTO userDTO = new UserDTO();
        userDTO.setUserId(user.getUserId());
        userDTO.setUserName(user.getUserName());
        userDTO.setUserEmail(user.getUserEmail());
        userDTO.setUserTel(user.getUserTel());
        userDTO.setGender(user.getGender());
        userDTO.setAge(user.getAge());
        userDTO.setAvatarPath(user.getAvatarPath());
        userDTO.setPostcode(user.getPostcode());
        userDTO.setAddress(user.getAddress());
        userDTO.setIsSubscribe(user.getIsSubscribe());
        return userDTO;
    }

//    @PostMapping(value = "/register", consumes = { "multipart/form-data" })
//    public ResponseEntity<Result> register(@Valid User user) {
//        Result result = userService.register(user);
//        return new ResponseEntity<>(result, HttpStatus.OK);
//
//    }

    @PostMapping("/login")
    public ResponseEntity<Result> login(@RequestParam String email, @RequestParam String password) {

        String hashedPassword = passwordEncoder.encode(password);

        User user = userRepository.findByUserEmail(email).orElse(null);
        Result result = new Result();

        if (user != null && passwordEncoder.matches(password, user.getPassword())) { // Encrypted passwords should
                                                                                     // be used in practical
                                                                                     // applications
            UserDTO userDTO = convertToDto(user);
            Map<String, Object> resultMap = new HashMap<>();
            resultMap.put("user",userDTO);

            result.setResultSuccess(0, resultMap);

            HttpHeaders headers = new HttpHeaders();
            Date exp = new Date();
            exp.setTime(exp.getTime() + 1000 * 60 * 60 * 24 * 7); // 7 days
            Map<String, Object> data = Map.of("user", userDTO);
            headers.add(HttpHeaders.AUTHORIZATION, "Bearer " + JWTManager.createToken(exp, data));
            headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, HttpHeaders.AUTHORIZATION);

            return new ResponseEntity<>(result, headers, HttpStatus.OK);
        } else {
            result.setResultFailed(1);
            return new ResponseEntity<>(result, HttpStatus.UNAUTHORIZED);
        }
    }

    @GetMapping("/users/me")
    public ResponseEntity<Result> getUserByAuthToken(@RequestHeader(HttpHeaders.AUTHORIZATION) String token) {
        Result result = new Result();
        if (token == null || token.isEmpty() || !token.contains("Bearer ")) {
            result.setResultFailed(4);
            return new ResponseEntity<>(result, HttpStatus.UNAUTHORIZED);
        }

        token = token.replace("Bearer ", "");

        UserDTO userDTO = JWTManager.getDataFromToken(token, "user", UserDTO.class);

        if (userDTO == null) {
            result.setResultFailed(4);
            return new ResponseEntity<>(result, HttpStatus.UNAUTHORIZED);
        }

        UserDTO updatedUserDTO = convertToDto(userRepository.findById(userDTO.getUserId()).orElse(null));

        if (updatedUserDTO == null) {
            result.setResultFailed(3);
            return new ResponseEntity<>(result, HttpStatus.NOT_FOUND);
        }

        Map<String, Object> resultMap = new HashMap<>();
        resultMap.put("user",updatedUserDTO);
        result.setResultSuccess(0, resultMap);

        HttpHeaders headers = new HttpHeaders();
        Date exp = new Date();
        exp.setTime(exp.getTime() + 1000 * 60 * 60 * 24 * 7); // 7 days
        Map<String, Object> data = Map.of("user", updatedUserDTO);
        headers.add(HttpHeaders.AUTHORIZATION, "Bearer " + JWTManager.createToken(exp, data));
        headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, HttpHeaders.AUTHORIZATION);

        return new ResponseEntity<>(result, headers, HttpStatus.OK);
    }


//    @PostMapping("/change-password")
//    public ResponseEntity<?> changePassword(@RequestBody PasswordChangeRequest request) {
//        try {
//            if (userService.changePassword(request)) {
//                return ResponseEntity.ok("Password changed successfully");
//            } else {
//                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Password change failed");
//            }
//        } catch (UsernameNotFoundException | InvalidVerificationCodeException ex) {
//            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ex.getMessage());
//        }
//    }




//    @GetMapping("users/{id}")
//    public ResponseEntity<Result> getUserById(@PathVariable Long id) {
//        Result result = new Result();
//
//        Map<String, Object> resultMap = new HashMap<>();
//        UserDTO userDTO = userService.findUserById(id);
//
//        if(userDTO != null){
//
//            resultMap.put("user",userDTO);
//            result.setResultSuccess(0, resultMap);
//            return new ResponseEntity<>(result, HttpStatus.OK);
//
//        } else {
//
//            result.setResultFailed(3);
//            return new ResponseEntity<>(result, HttpStatus.NOT_FOUND);
//        }
//
//
//    }
//    @PutMapping(value = "/users/{id}", consumes = { "multipart/form-data" })
//    public ResponseEntity<Result> updateUser(@RequestHeader(HttpHeaders.AUTHORIZATION) String token, @PathVariable Long id,User updatedUser) {
//        Result result = new Result();
//
//        if (token == null || token.isEmpty() || !JWTManager.checkToken(token.substring(7), id)) {
//            result.setResultFailed(4);
//            return new ResponseEntity<>(result, HttpStatus.UNAUTHORIZED);
//        }
//
//        User user = userService.updateUser(id, updatedUser);
//
//        UserDTO userDTO = convertToDto(user);
//        Map<String, Object> resultMap = new HashMap<>();
//        resultMap.put("user",userDTO);
//        result.setResultSuccess(0, resultMap);
//
//        HttpHeaders headers = new HttpHeaders();
//        return new ResponseEntity<>(result, HttpStatus.OK);
//    }
}